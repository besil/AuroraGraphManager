{"name":"Auroragraphmanager","tagline":"Efficient graph data structures","body":"Aurora Graph Manager\r\n==================\r\n\r\nAurora Graph Manager is part of the software I developed for my MS thesis in Computer Science.\r\nThe thesis was about community detection in big graphs.\r\n\r\nAurora is an efficient in-memory implementation for directed, undirected, weighted and unweighted graphs, written in Java.\r\nMost of the performance is given by the fastutil project (http://fastutil.di.unimi.it).\r\n\r\nI'm rewriting the code in Java 8, with functional idioms. With the original implementation, we could handle\r\ngraphs with 300 milions of edges in a 60 Gb server.\r\n\r\nIf you want to download the .jar, go to \r\nhttps://sites.google.com/site/silviobernardinello/my-projects\r\n\r\nQuickstart\r\n==================\r\n\r\nIn Aurora, nodes and edges have an unique identifier. For nodes, it's supplied by the programmer, while edges are\r\nautomatically indexed. Nodes can have a float attribute, while edge have a default weight 1f.\r\n\r\nCreating a graph is trivial:\r\n\r\n```java\r\n/**\r\n * Populate the graph\r\n */\r\nGraph g = new AdlDirectGraph();\t// or AdlUndirectGraph\r\nint n0 = g.addNode(0);          // Add a simple node\r\ng.addNode(1, 1f);               // Add node with a float label\r\n\r\n// check if there are only 2 nodes in the graph\r\nassertEquals(2, g.getNodeCount());\r\n\r\nint edgeId = g.addEdge(2, 3, 1f); // Node 2 and 3 are automatically created\r\ng.addEdge(3, 4, 3f);  \r\ng.addEdge(4, 2);                // This edge has weight 1f\r\n\r\nassertEquals(3, g.getEdgeCount());\r\n\r\n// You can change node attribute for an existing node\r\ng.setNodeAttribute(n0, 4f);\r\n\r\n// Create and delete nodes\r\ng.addNode(24);\r\nif( g.contains(24) )\r\n\tg.removeNode(24);\r\nassertEquals(false, g.contains(24));\r\n\r\ntry {\r\n\tg.getNodeAttribute(23);       // You can't access to non existing nodes\r\n\tassertEquals(true, false);\r\n} catch( NodeNotFound ex ) {\r\n\t// this is a RuntimeException\r\n\tassertEquals(true, true);\r\n}\r\n\r\n/**\r\n * Edge Operations\r\n */\r\ng = new AdlDirectGraph();\r\ng.addEdge(0, 1);\r\ng.addEdge(0, 2);\r\n// check connections\r\nassertEquals(true, g.areConnected(0, 1));\r\n\r\nedgeId = g.getEdgeBetween(0, 1);\t// get the id between 0 and 1\r\nIntSet outEdges = g.getOutEdges(0);\t// also getInEdge or getEdges()\r\nassertEquals( true, outEdges.contains(edgeId) );\r\n\r\ntry {\r\n\tg.getEdgeBetween(0, 23);\r\n\tassertEquals(true, false);\r\n} catch( EdgeNotFound ex ) {\r\n\tassertEquals(true, true);\r\n}\r\n\r\nfloat w = g.getEdgeWeight(edgeId);\r\nassertEquals( 1f, w, 0.0 );\t\t\t// default weight is 1f\r\nfloat nonExistingEdge = g.getEdgeWeight(-23);\r\n// Beware! this is true! If you ask the weight of an existing\r\n// edge, you get it. Of an non existing edge, you get 1f. \r\n// This is made for performance.\r\nassertEquals( 1f, nonExistingEdge, 0.0 );\r\n\r\n/**\r\n * Neighborhood\r\n */\r\ng = new AdlUndirectGraph();\r\ng.addEdge(0, 1);\r\ng.addEdge(0, 2);\r\n\r\nIntSet neighs = new IntArraySet(new int[]{1, 2});\r\nassertEquals(neighs, g.getNeighbours(0));\r\n// Also getOutNeighbours or getInNeighbours. Make sense only for directed graph\r\n\r\n/**\r\n * Graph View\r\n */\r\ng.addEdge(2, 3);\r\ng.addEdge(2, 4);\r\ng.addEdge(3, 4);\r\nIntSet subgraph = new IntArraySet(new int[]{ 2,3,4 } );\r\n// Graph view gives you a view on some vertices\r\nIGraph ig = new GraphView(g, subgraph);\t// IGraph is the immutable interface for Graph\r\n\r\nassertEquals(false, ig.contains(0));\r\nassertEquals(true, ig.contains(2));\r\n\r\n/**\r\n * Degree\r\n */\r\n// You can get degree information for nodes\r\ng = new AdlDirectGraph();\r\ng.addEdge(0, 1, 2f);\r\ng.addEdge(0, 2);\r\ng.addEdge(2, 0);\r\n\r\nassertEquals(2, g.outDegree(0));\r\nassertEquals(1, g.inDegree(0));\r\nassertEquals(3, g.degree(0));\r\n\r\n// Also wOutDegree(0) for weighted degree\r\nassertEquals(3f, g.wOutDegree(0), 0.0);\r\n\r\n/**\r\n * Finally, the edge iterator feature\r\n */\r\n// Iterate over triplets {edgeId, src, dst}\r\ng = new AdlDirectGraph();\r\ng.addEdge(0, 1);\r\ng.addEdge(0, 2);\r\ng.addEdge(2, 3);\r\nfor(int[] t : g.getEdgeIterable()) {\r\n\tSystem.out.println(t[0]+\": \"+t[1]+\" -> \"+t[2]);\r\n\t/*\r\n\t * Prints\r\n\t * 0: 0 -> 1\r\n\t * 1: 0 -> 2\r\n\t * 2: 2 -> 3\r\n\t */\r\n}\r\n```\r\n","google":"UA-68394103-1","note":"Don't delete this file! It's used internally to help with page regeneration."}